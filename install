#!/bin/bash

# SPDX-FileCopyrightText: 2016 - 2024 sudorook <daemon@nullcodon.com>
#
# SPDX-License-Identifier: GPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program. If not, see <https://www.gnu.org/licenses/>.

set -euo pipefail

DIR="$(dirname "$0")"
TIMEZONE="UTC"
HOST_NAME="Arch"
USER_NAME="nick"
LOCALE="en_US.UTF-8"
CHARSET="UTF-8"
BOOTMODE="systemd-boot" # systemd-boot or GRUB

show_error() {
  local red=$'\033[0;91m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${red}${*:2}${nc}" 1>&2
  else
    echo -e "${red}${*}${nc}" 1>&2
  fi
}
export -f show_error

show_info() {
  local green=$'\033[0;92m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${green}${*:2}${nc}"
  else
    echo -e "${green}${*}${nc}"
  fi
}
export -f show_info

show_warning() {
  local yellow=$'\033[0;93m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${yellow}${*:2}${nc}"
  else
    echo -e "${yellow}${*}${nc}"
  fi
}
export -f show_warning

show_question() {
  local blue=$'\033[0;94m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${blue}${*:2}${nc}"
  else
    echo -e "${blue}${*}${nc}"
  fi
}
export -f show_question

ask_question() {
  local blue=$'\033[0;94m'
  local nc=$'\033[0m'
  local var
  read -r -p "${blue}$*${nc} " var
  echo "${var}"
}
export -f ask_question

ask_secret() {
  local blue=$'\033[0;94m'
  local nc=$'\033[0m'
  local var
  stty -echo echonl
  read -r -p "${blue}$*${nc} " var
  stty echo -echonl
  echo "${var}"
}
export -f ask_secret

show_success() {
  local purple=$'\033[0;95m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${purple}${*:2}${nc}"
  else
    echo -e "${purple}${*}${nc}"
  fi
}
export -f show_success

show_header() {
  local cyan=$'\033[0;96m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${cyan}${*:2}${nc}"
  else
    echo -e "${cyan}${*}${nc}"
  fi
}
export -f show_header

show_listitem() {
  local white=$'\033[0;97m'
  local nc=$'\033[0m'
  if [[ "${1:--e}" =~ ^(-e|-n)$ ]]; then
    echo "${1:--e}" "${white}${*:2}${nc}"
  else
    echo -e "${white}${*}${nc}"
  fi
}
export -f show_listitem

#
# Utility functions
#

function check_root {
  if [ ${EUID} -eq 0 ]; then
    show_info "I am root."
  else
    show_error "I need to be root."
    exit 1
  fi
}

function check_sync_repos {
  local last_update

  # Check the pacman log to see if synchronized within the past hour. If so,
  # return.
  if [ -f /var/log/pacman.log ]; then
    last_update="$(grep -a "synchronizing package lists$" /var/log/pacman.log |
                   tail -n 1 |
                   sed -n "s/\[\(.*\)\] \[PACMAN\] .*/\1/p")"
    if [ -n "${last_update}" ]; then
      if [ "$(date --date="${last_update}" +%s)" -gt \
           "$(date --date="1 hour ago" +%s)" ]; then
        return
      fi
    fi
  fi

  sync_repos
}

function sync_repos {
  show_header "Synchronizing repos."
  if [ ${EUID} -eq 0 ]; then
    pacman -Sy
  else
    sudo pacman -Sy
  fi
}

function check_install_commands {
  local install_cmds=(
    arch-chroot
    cryptsetup
    findmnt
    fzf
    genfstab
    lvcreate
    mount
    pacstrap
    partprobe
    pvcreate
    sed
    sgdisk
    umount
    vgcreate
  )
  local c
  for c in "${install_cmds[@]}"; do
    if ! command -v "${c}" > /dev/null 2>&1; then
      return 1
    fi
  done
}

install_dependencies() {
  local install=(
    arch-install-scripts
    bc
    cryptsetup
    curl
    dosfstools
    findutils
    fzf
    git
    gptfdisk
    grep
    pacman
    pacman-contrib
    pacman-mirrorlist
    parted
    sed
  )

  show_header "Checking installation dependencies."
  local missing=()
  for exe in "${install[@]}"; do
    if ! command -v "$exe" &>/dev/null && ! pacman -Qi "$exe" &>/dev/null; then
      missing+=("$exe")
    fi
  done
  pacman -Sy --noconfirm archlinux-keyring
  if ((${#missing[@]} == 0)); then
    return 0
  else
    for pkg in "${missing[@]}"; do
      show_info "${pkg@Q} is needed for this script."
      pacman -S --noconfirm "$pkg"
      show_success "${pkg@Q} installed."
    done
  fi
}

function check_network {
  show_header "Checking network connection."

  if ! command -v curl > /dev/null 2>&1; then
    show_error "curl not installed. Exiting."
    exit 1
  fi

  if curl -Is --retry 5 --retry-connrefused https://archlinux.org > /dev/null; then
    show_success "Network is working."
  else
    show_error "Cannot start network connection."
    exit 1
  fi
}

function set_config_key_value {
  local file="${1}"
  local key="${2}"
  local value="${3}"

  if [ -f "${file}" ]; then
    if grep -q "^${key}" "${file}"; then
      sed -i "s,^${key}=.*,${key}=${value},g" "${file}"
    else
      echo "${key}=${value}" >> "${file}"
    fi
  else
    show_warning "${file@Q} does not exist. Creating new."
    mkdir -p "$(dirname "${file}")"
    echo "${key}=${value}" > "${file}"
  fi
}

function copy_config_file {
  local source="${1}"
  local dest="${2}"

  if ! [ -f "${source}" ]; then
    show_error "${source@Q} not found. Exiting."
    exit 1
  fi

  show_info "Copying ${source@Q} to ${dest@Q}."
  if [ -f "${dest}" ]; then
    if ! cmp -s "${source}" "${dest}"; then
      show_info "Backing up existing ${dest@Q}."
      mv -v "${dest}" "${dest}_$(date +%Y%m%d-%H%M%S).bak"
      cp -v "${source}" "${dest}"
    else
      show_info "${dest} already set."
    fi
  else
    mkdir -p "$(dirname "${dest}")"
    cp -v "${source}" "${dest}"
  fi
}

function is_size_nonzero {
  if [[ "${1}" != "0" ]] &&
     [[ "${1}" != "0G" ]] &&
     [[ "${1}" != "0GiB" ]] &&
     [[ "${1}" != "0GB" ]] &&
     [[ "${1}" != "0Gb" ]] &&
     [[ "${1}" != "[N|n][O|o]" ]] &&
     [[ "${1}" != "[N|n][ONE|one]" ]]; then
    return 0
  else
    return 1
  fi
}
export -f is_size_nonzero

DEVICE=
function ask_device {
  local disks
  local disk
  local result

  # NOTE:lsblk returns without '/dev/' prefix.
  mapfile -t disks < <(lsblk -nd -o NAME,TYPE | grep disk | cut -d' ' -f1)
  if ! [[ -v disks ]]; then
    show_error "No disk devices found. Exiting."
    exit 1
  fi

  show_header "Device for installation:"
  select disk in "${disks[@]}"; do
    if [ -z "${disk}" ]; then
      show_warning "Invalid selection. Try again."
      continue
    fi
    if check_disk "${disk}"; then
      DEVICE="${disk}"
      break
    fi
  done
}

function check_disk {
  local disk="${1}"
  local reply
  if ! [ -b "/dev/${disk}" ]; then
    show_warning "${disk@Q} not a block deice."
    return 1
  fi
  if findmnt --source "/dev/${disk}" > /dev/null; then
    show_warning "disk ${disk@Q} already mounted. Unmount and try again."
    findmnt --source "/dev/${disk}"
    return 1
  fi
  if blkid -p "/dev/${disk}" > /dev/null; then
    show_warning "Partition scheme already exists on ${disk}."
    reply="$(ask_question "Wipe /dev/${disk}? (y/N)")"
    if [[ "${reply}" =~ ^[Yy]$|[Yy][Ee][Ss] ]]; then
      unmount_disk "${disk}"
      sgdisk -Z "/dev/${disk}"
      partprobe "/dev/${disk}"
    else
      return 1
    fi
  fi
}

function unmount_disk {
  local disk="${1}"
  local names
  local mountpoints
  local idx

  mapfile -t names < <(lsblk -lpno NAME "/dev/${disk}")
  mapfile -t mountpoints < <(lsblk -lpno MOUNTPOINTS "/dev/${disk}")

  for idx in "${!mountpoints[@]}"; do
    if [ -z "${mountpoints["${idx}"]}" ]; then
      continue
    else
      umount -R "${mountpoints["${idx}"]}"
    fi
  done
}

MAKE_EFI_PARTITION=yes
function check_bootmode {
  show_header "Boot system:"
  if [ ! -e /sys/firmware/efi ]; then
    show_info "EFI support not detected. Defaulting to GRUB."
    BOOTMODE="GRUB"
    result="$(ask_question "Create EFI partition anyway? (y/N)")"
    if ! [[ "${result}" =~ ^[Yy]$|[Yy][Ee][Ss] ]]; then
      MAKE_EFI_PARTITION=no
    fi
  fi
}

function sanitize_size_input {
  local value
  local suffix
  value="$(echo "${1}" | sed -n 's/^\([0-9\.]\+\)\ *[A-Za-z]*/\1/p')"
  suffix="$(echo "${1}" | sed -n 's/^[0-9\.]\+\ *\([A-Za-z]\+\)/\1/p')"

  # if using base 10 units
  if [[ "${1}" = "fill" ]]; then
    value="${1}"

  elif [[ "${suffix}" =~ ^[Pp]etabyte|^[Pp][Bb]s?$ ]]; then
    value="$(echo "${value} * 1000^5 / 1024" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Tt]erabyte|^[Tt][Bb]s?$ ]]; then
    value="$(echo "${value} * 1000^4 / 1024" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Gg]igabyte|^[Gg][Bb]s?$ ]]; then
    value="$(echo "${value} * 1000^3 / 1024" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Mm]egabyte|^[Mm][Bb]s?$ ]]; then
    value="$(echo "${value} * 1000^2 / 1024" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Kk]ilobyte|^[Kk][Bb]s?$ ]]; then
    value="$(echo "${value} * 1000^1 / 1024" | bc -l)"
    value="${value%.*}k"

  elif [[ "${suffix}" =~ ^[Pp]ebibyte|^[Pp]i[Bb]s?$|^[Pp]$ ]]; then
    value="$(echo "${value} * 1024^4" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Tt]ebibyte|^[Tt]i[Bb]s?$|^[Tt]$ ]]; then
    value="$(echo "${value} * 1024^3" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Gg]ibibyte|^[Gg]i[Bb]s?$|^[Gg]$ ]]; then
    value="$(echo "${value} * 1024^2" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Mm]ebibyte|^[Mm]i[Bb]s?$|^[Mm]$ ]]; then
    value="$(echo "${value} * 1024^1" | bc -l)"
    value="${value%.*}k"
  elif [[ "${suffix}" =~ ^[Ki]ibibyte|^[Kk]i[Bb]s?$|^[Kk]$ ]]; then
    value="${value}k"
  else
    value="${value}${suffix}"
  fi

  echo "${value}" # output in kibibytes
}

function subtract {
  local input1="${1}"
  local input2="${2}"

  if [[ "${input1}" =~ P$ ]]; then
    input1=${input1/P/}
    input1=$(echo "${input1} * 1024^5" | bc -l)
  elif [[ "${input1}" =~ T$ ]]; then
    input1=${input1/T/}
    input1=$(echo "${input1} * 1024^4" | bc -l)
  elif [[ "${input1}" =~ G$ ]]; then
    input1=${input1/G/}
    input1=$(echo "${input1} * 1024^3" | bc -l)
  elif [[ "${input1}" =~ M$ ]]; then
    input1=${input1/M/}
    input1=$(echo "${input1} * 1024^2" | bc -l)
  elif [[ "${input1}" =~ k$ ]]; then
    input1=${input1/k/}
    input1=$(echo "${input1} * 1024" | bc -l)
  # else
  #   input1=$(echo "${input1}" | bc -l)
  fi

  if [[ "${input2}" =~ P$ ]]; then
    input2=${input2/P/}
    input2=$(echo "${input2} * 1024^5" | bc -l)
  elif [[ "${input2}" =~ T$ ]]; then
    input2=${input2/T/}
    input2=$(echo "${input2} * 1024^4" | bc -l)
  elif [[ "${input2}" =~ G$ ]]; then
    input2=${input2/G/}
    input2=$(echo "${input2} * 1024^3" | bc -l)
  elif [[ "${input2}" =~ M$ ]]; then
    input2=${input2/M/}
    input2=$(echo "${input2} * 1024^2" | bc -l)
  elif [[ "${input2}" =~ k$ ]]; then
    input2=${input2/k/}
    input2=$(echo "${input2} * 1024" | bc -l)
  # else
  #   input2=$(echo "${input2}" | bc -l)
  fi

  if [ "$(echo "${input1} >= ${input2}" | bc -l)" = 1 ]; then
    output="$(echo "${input1} - ${input2}" | bc -l)"
  else
    show_error "ERROR: not enough (remaining) space."
    return 1
  fi
  echo "${output%.*}"
}

function get_base2 {
  local value="${1}"
  local suffix=""
  local exp=0

  while [ "$(echo "1024^${exp} > ${value}" | bc)" = 0 ]; do
    exp=$((exp + 1))
  done
  exp=$((exp - 1))
  value="$(echo "${value} / 1024^${exp}" | bc)"

  case "${exp}" in
    1) suffix="KiB" ;;
    2) suffix="MiB" ;;
    3) suffix="GiB" ;;
    4) suffix="TiB" ;;
    5) suffix="PiB" ;;
    6) echo "${exp} --- huh?" && exit 3 ;;
  esac

  echo "${value}${suffix}"
}

function get_base10 {
  local value="${1}"
  local suffix=""
  local exp=0
  while [ "$(echo "1000^${exp} > ${value}" | bc)" = 0 ]; do
    exp=$((exp + 1))
  done
  exp=$((exp - 1))
  value="$(echo "${value} / 1000^${exp}" | bc)"

  case "${exp}" in
    1) suffix="k" ;;
    2) suffix="M" ;;
    3) suffix="G" ;;
    4) suffix="T" ;;
    5) suffix="P" ;;
    6) echo "${exp} --- huh?" && exit 3 ;;
  esac

  echo "${value}${suffix}"
}

declare -A PARTITIONS
PARTITIONS=([root]="20G" [home]="fill" [share]="0G")
function ask_partition_sizes {
  local free_size
  local home
  local root
  local share
  local all_good=false

  while ! "${all_good}"; do
    free_size="$(lsblk -b -dno SIZE "/dev/${DEVICE}")"

    show_header "Specify partition sizes. $(get_base10 "${free_size}") ($(get_base2 "${free_size}")) available:"
    share=$(ask_question "Share (default=0GiB):")
    share=$(sanitize_size_input "${share}")
    if [[ -n "${share}" ]]; then
      PARTITIONS["share"]="${share}"
      if [[ "${share}" = "fill" ]]; then
        show_warning "WARNING: Leave space for the OS installation."
        continue
      else
        if ! free_size="$(subtract "${free_size}" "${share}")"; then
          show_warning "WARNING: Invalid partition size(s). Try again."
          continue
        fi
      fi
    else
      share="${PARTITIONS["share"]}"
      if ! free_size="$(subtract "${free_size}" "${share}")"; then
        show_warning "WARNING: Invalid partition size(s). Try again."
        continue
      fi
    fi
    show_info "$(get_base10 "${free_size}") ($(get_base2 "${free_size}")) available"

    root=$(ask_question "Root (default=20GiB; enter 'fill' to use remaining space):")
    root=$(sanitize_size_input "${root}")
    if [[ -n "${root}" ]]; then
      PARTITIONS["root"]="${root}"
      if [[ "${root}" = "fill" ]]; then
        free_size="0G"
      else
        if ! free_size="$(subtract "${free_size}" "${root}")"; then
          show_warning "WARNING: Invalid partition size(s). Try again."
          continue
        fi
      fi
    else
      root="${PARTITIONS["root"]}"
      if ! free_size="$(subtract "${free_size}" "${root}")"; then
        show_warning "WARNING: Invalid partition size(s). Try again."
        continue
      fi
    fi
    show_info "$(get_base10 "${free_size}") ($(get_base2 "${free_size}")) available"

    if [[ "${PARTITIONS["root"]}" != "fill" ]]; then
      if [ "${free_size}" -lt 4883704320 ]; then
        show_warning "WARNING: Leave >5GiB for /home partition."
        continue
      fi
      home=$(ask_question "Home (default=fill):")
      home=$(sanitize_size_input "${home}")
      if [[ -n "${home}" ]]; then
        PARTITIONS["home"]="${home}"
        if [[ "${home}" = "fill" ]]; then
          free_size="0G"
        else
          if ! free_size="$(subtract "${free_size}" "${home}")"; then
            show_warning "WARNING: Invalid partition size(s). Try again."
            continue
          fi
        fi
      else
        home="${PARTITIONS["home"]}"
        if ! free_size="$(subtract "${free_size}" "${home}")"; then
          show_warning "WARNING: Invalid partition size(s). Try again."
          continue
        fi
      fi
      show_info "$(get_base10 "${free_size}") ($(get_base2 "${free_size}")) available"
    else
      PARTITIONS["home"]=0
    fi

    all_good=true
  done
}

EFI_PARTITION=
ROOT_PARTITION=
HOME_PARTITION=
SHARE_PARTITION=
function set_partitions {
  show_header "Writing partitions to ${DEVICE}..."
  sgdisk -Z "/dev/${DEVICE}"
  partprobe "/dev/${DEVICE}"

  local sgdisk_opts
  local part_count
  sgdisk_opts="--clear"
  sgdisk_opts="${sgdisk_opts} --new=1:0:+1MiB --typecode=1:ef02"
  part_count=2

  local add_p=false
  if [[ "${DEVICE}" =~ [[:digit:]]$ ]]; then
    add_p=true
  fi

  if [[ "${MAKE_EFI_PARTITION}" = "yes" ]]; then
    sgdisk_opts="${sgdisk_opts} --new=2:0:+1024MiB --typecode=${part_count}:ef00"
    if "${add_p}"; then
      EFI_PARTITION="/dev/${DEVICE}p${part_count}"
    else
      EFI_PARTITION="/dev/${DEVICE}${part_count}"
    fi
    part_count=$((part_count + 1))
  fi

  if is_size_nonzero "${PARTITIONS["share"]}"; then
    sgdisk_opts="${sgdisk_opts} --new=${part_count}:0:+${PARTITIONS["share"]} --typecode=${part_count}:0700"
    if "${add_p}"; then
      SHARE_PARTITION="/dev/${DEVICE}p${part_count}"
    else
      SHARE_PARTITION="/dev/${DEVICE}${part_count}"
    fi
    part_count=$((part_count + 1))
  fi

  if is_size_nonzero "${PARTITIONS["root"]}"; then
    if [[ "${PARTITIONS["root"]}" = "fill" ]]; then
      sgdisk_opts="${sgdisk_opts} --new=${part_count}:0:0 --typecode=${part_count}:8300"
      if "${add_p}"; then
        ROOT_PARTITION="/dev/${DEVICE}p${part_count}"
      else
        ROOT_PARTITION="/dev/${DEVICE}${part_count}"
      fi
      part_count=$((part_count + 1))
    else
      sgdisk_opts="${sgdisk_opts} --new=${part_count}:0:+${PARTITIONS["root"]} --typecode=${part_count}:8300"
      if "${add_p}"; then
        ROOT_PARTITION="/dev/${DEVICE}p${part_count}"
      else
        ROOT_PARTITION="/dev/${DEVICE}${part_count}"
      fi
      part_count=$((part_count + 1))
      if is_size_nonzero "${PARTITIONS["home"]}"; then
        if [[ "${PARTITIONS["home"]}" = "fill" ]]; then
          sgdisk_opts="${sgdisk_opts} --new=${part_count}:0:0 --typecode=${part_count}:8300"
          if "${add_p}"; then
            HOME_PARTITION="/dev/${DEVICE}p${part_count}"
          else
            HOME_PARTITION="/dev/${DEVICE}${part_count}"
          fi
          part_count=$((part_count + 1))
        else
          sgdisk_opts="${sgdisk_opts} --new=${part_count}:0:+${PARTITIONS["home"]} --typecode=${part_count}:8300"
          if "${add_p}"; then
            HOME_PARTITION="/dev/${DEVICE}p${part_count}"
          else
            HOME_PARTITION="/dev/${DEVICE}${part_count}"
          fi
          part_count=$((part_count + 1))
        fi
      fi
    fi
  fi

  local cmd
  cmd="sgdisk ${sgdisk_opts} /dev/${DEVICE}"
  eval "${cmd}"
  sync
}

function format_partitions {
  if [ -b "${EFI_PARTITION}" ]; then
    mkfs.vfat -F32 "${EFI_PARTITION}"
  fi
  if [ -b "${ROOT_PARTITION}" ]; then
    mkfs.ext4 "${ROOT_PARTITION}"
  fi
  if [ -b "${HOME_PARTITION}" ]; then
    mkfs.ext4 "${HOME_PARTITION}"
  fi
  if [ -b "${SHARE_PARTITION}" ]; then
    mkfs.vfat -F 32 -n SHARE "${SHARE_PARTITION}"
  fi
}

function mount_install {
  mount "${ROOT_PARTITION}" /mnt
  if [ -b "${EFI_PARTITION}" ]; then
    mkdir -p /mnt/efi
    mount "${EFI_PARTITION}" /mnt/efi
  fi
  if [ -e "${HOME_PARTITION}" ]; then
    mkdir -p /mnt/home
    mount "${HOME_PARTITION}" /mnt/home
  fi
}

function unmount_install {
  umount -R /mnt
}

function set_timezone {
  ln -sfn "/usr/share/zoneinfo/${TIMEZONE}" /etc/localtime
  hwclock --systohc --utc
}
export -f set_timezone

function set_locale {
  local keymap
  sed -i "/^#${LOCALE} ${CHARSET}/s/^#//" /etc/locale.gen
  locale-gen
  echo "LANG=${LOCALE}" > /etc/locale.conf
  keymap="$(echo "${LOCALE}" | sed -n "s/\([a-z]\+\)_\([A-Z]\+\)[@\ \.].*/\2/p")"
  echo "KEYMAP=${keymap,,}" > /etc/vconsole.conf
}
export -f set_locale

function set_hostname {
  echo "${HOST_NAME}" > /etc/hostname
}
export -f set_hostname

USER_PASSWORD=""
function ask_password {
  local tmp1
  local tmp2
  local is_invalid=true
  while "${is_invalid}"; do
    tmp1="$(ask_secret "User password")"
    tmp2="$(ask_secret "Re-enter password")"
    if [ -z "${tmp1}" ]; then
      show_error "ERROR: no password given."
      continue
    elif [ "${tmp1}" != "${tmp2}" ]; then
      show_error "ERROR: password mismatch."
      continue
    else
      USER_PASSWORD="${tmp1}"
      is_invalid=false
    fi
  done
}

function add_user {
  useradd -m -c "${USER_NAME[@]^}" "${USER_NAME}" -s /bin/bash
  usermod -aG wheel,"${USER_NAME}" "${USER_NAME}"
  echo "${USER_NAME}:${USER_PASSWORD}" | chpasswd

  sed -e "s/^# \(%wheel ALL=(ALL:\?\(ALL\)\?) ALL\)$/\1/g" /etc/sudoers |
    EDITOR="tee" visudo > /dev/null
}
export -f add_user

function disable_root {
  passwd -l root
}
export -f disable_root

function set_mkinitcpio {
  local old_hooks
  local new_hooks
  local modules
  local vendor

  old_hooks="$(sed -n "s/^HOOKS=(\(.*\))$/\1/p" /etc/mkinitcpio.conf)"
  new_hooks="$(echo "${old_hooks}" |
               sed -e 's/udev/systemd/g' \
                   -e 's/keymap consolefont/sd-vconsole/g')"
  sed -i "s/${old_hooks}/${new_hooks}/g" /etc/mkinitcpio.conf

  vendor="$(lscpu | sed -n "s,^Vendor ID: \+\([A-Za-z]\+\),\1,p")"
  modules="$(sed -n "s/^MODULES=(\(.*\))$/\1/p" /etc/mkinitcpio.conf)"
  if [[ "${vendor}" =~ "AMD" ]]; then
    if ! grep -q "^MODULES.*amdgpu" /etc/mkinitcpio.conf; then
      if [ -n "${modules}" ]; then
        sed -i "s/^MODULES=(\(.*\))$/MODULES=(\1 amdgpu)/g" /etc/mkinitcpio.conf
      else
        sed -i "s/^MODULES=()$/MODULES=(amdgpu)/g" /etc/mkinitcpio.conf
      fi
    fi
  elif [[ "${vendor}" =~ "Intel" ]]; then
    if ! grep -q "^MODULES.*i915" /etc/mkinitcpio.conf; then
      if [ -n "${modules}" ]; then
        sed -i "s/^MODULES=(\(.*\))$/MODULES=(\1 i915)/g" /etc/mkinitcpio.conf
      else
        sed -i "s/^MODULES=()$/MODULES=(i915)/g" /etc/mkinitcpio.conf
      fi
    fi
  fi

  mkinitcpio -P
}
export -f set_mkinitcpio

function install_ucode {
  vendor="$(lscpu | sed -n "s,^Vendor ID: \+\([A-Za-z]\+\),\1,p")"
  if [[ "$vendor" =~ "AMD" ]]; then
    pacman -S --noconfirm amd-ucode
  elif [[ "$vendor" =~ "Intel" ]]; then
    pacman -S --noconfirm intel-ucode
  fi
}
export -f install_ucode

function install_gummiboot {
  if ! command -v bootctl > /dev/null 2>&1; then
    pacman -S --noconfirm systemd
  fi

  pacman -S --noconfirm efibootmgr

  local root_uuid
  local cmdline

  root_uuid=$(sed -n "s,^UUID=\(\S\+\)\s\+/\s\+.*,\1,p" /etc/fstab)

  if [ -n "${root_uuid}" ]; then
    cmdline="root=UUID=${root_uuid} rw"
  else
    cmdline="rw"
  fi

  bootctl --esp-path=/efi install
  systemctl enable systemd-boot-update
  systemctl enable efi-update@linux.path
  cp -af /boot/vmlinuz* /boot/initramfs-linux* /efi
  mkdir -p /efi/loader/entries

  cat > /efi/loader/loader.conf << EOF
default	linux.conf
timeout	1
console-mode	max
editor	no
EOF

  cat > /efi/loader/entries/linux.conf << EOF
title	Arch Linux, linux
linux	/vmlinuz-linux
initrd	/initramfs-linux.img
options	${cmdline}
EOF

  cat > /efi/loader/entries/linux-fallback.conf << EOF
title	Arch Linux, linux (fallback)
linux	/vmlinuz-linux
initrd	/initramfs-linux-fallback.img
options	${cmdline}
EOF
}
export -f install_gummiboot

function install_grub {
  pacman -S --noconfirm grub os-prober efibootmgr

  local root_uuid
  local cmdline

  root_uuid=$(sed -n "s,^UUID=\(\S\+\)\s\+/\s\+.*,\1,p" /etc/fstab)

  if grep -q ^GRUB_EARLY_INITRD_LINUX_STOCK /etc/default/grub; then
    sed -i 's/^GRUB_EARLY_INITRD_LINUX_STOCK=.*/GRUB_EARLY_INITRD_LINUX_STOCK=""/g' /etc/default/grub
  else
    sed -i '/^GRUB_CMDLINE_LINUX=/a GRUB_EARLY_INITRD_LINUX_STOCK=""' /etc/default/grub
  fi

  if [ -e /sys/firmware/efi ]; then
    grub-install --target=x86_64-efi --efi-directory=/efi --bootloader-id=GRUB --recheck
  fi
  grub-install --target=i386-pc "/dev/${DEVICE}" --recheck
  grub-mkconfig -o /boot/grub/grub.cfg
}
export -f install_grub

function update_mirrorlist {
  pacman -Sy --noconfirm reflector
  reflector --verbose --latest 10 --protocol https --sort rate --save /etc/pacman.d/mirrorlist
  pacman -Sy
}
export -f update_mirrorlist

function install_packages {
  pacman --noconfirm -S \
    base-devel \
    bash-completion \
    curl \
    fzf \
    git \
    iwd \
    linux \
    linux-firmware \
    linux-headers \
    man-db \
    man-pages \
    pacman-contrib \
    rsync
  systemctl enable iwd
}
export -f install_packages

#
# Define main select wrapper
#

function main {
  ask_device
  check_bootmode
  ask_partition_sizes

  ask_password

  set_partitions
  format_partitions

  mount_install
  pacstrap /mnt base
  genfstab -U /mnt >> /mnt/etc/fstab
  if [[ "${BOOTMODE}" = "systemd-boot" ]]; then
    sed -i "/\(.*\)\s\+\/efi\s\+vfat/s/0022/0077/g" /mnt/etc/fstab
  fi
  TIMEZONE="${TIMEZONE}" arch-chroot /mnt /bin/bash -c "set_timezone"
  LOCALE="${LOCALE}" CHARSET="${CHARSET}" \
    arch-chroot /mnt /bin/bash -c "set_locale"

  arch-chroot /mnt /bin/bash -c "update_mirrorlist"
  arch-chroot /mnt /bin/bash -c "install_packages"
  arch-chroot /mnt /bin/bash -c "install_ucode"
  HOST_NAME="${HOST_NAME}" arch-chroot /mnt /bin/bash -c "set_hostname"
  USER_NAME="${USER_NAME}" USER_PASSWORD="${USER_PASSWORD}" arch-chroot /mnt /bin/bash -c "add_user"
  arch-chroot /mnt /bin/bash -c "disable_root"
  arch-chroot /mnt /bin/bash -c "set_mkinitcpio"
  if [[ "${BOOTMODE}" == "GRUB" ]]; then
    SCHEME="${SCHEME}" DEVICE="${DEVICE}" \
      arch-chroot /mnt /bin/bash -c "install_grub"

  elif [[ "${BOOTMODE}" == "systemd-boot" ]]; then
    cp -f \
      "${DIR}/hooks/efi-update@.path" \
      "${DIR}/hooks/efi-update@.service" \
      /mnt/etc/systemd/system/

    cp -f "${DIR}/utils/sdboot-mkconfig" /mnt/usr/local/sbin/
    chmod +x /mnt/usr/local/sbin/sdboot-mkconfig

    SCHEME="${SCHEME}" DEVICE="${DEVICE}" \
      arch-chroot /mnt /bin/bash -c "install_gummiboot"
  fi
  unmount_install
  show_success "Done! Reboot now."
}

#
# Check if dependencies are installed and if network is working
#

check_root
check_network
if ! check_install_commands; then
  check_sync_repos
  install_dependencies
fi

#
# GO!!!
#

main
